var b=Object.defineProperty;var o=(e,r)=>b(e,"name",{value:r,configurable:!0});import{COMPRESSIBLE_CONTENT_TYPE_REGEX as _}from"hono/utils/compress";import g from"@mongodb-js/zstd";const A="Cloudflare-Workers",w=["zstd","br","gzip","deflate"],O=/(?:^|,)\s*no-transform\s*(?:,|$)/i,D=1024,S=2,I=4,k=6,N=globalThis.navigator?.userAgent===A,y=globalThis.Deno?.env?.get("DENO_DEPLOYMENT_ID")!==void 0;function P(e,r){const t=e.headers.get("Content-Type");return t?_.test(t):r}o(P,"shouldCompress");function z(e){const r=e.headers.get("Cache-Control");return!r||!O.test(r)}o(z,"shouldTransform");const B=import("node:zlib");let c;B.then(e=>{c=e}).catch(()=>null);class C extends TransformStream{static{o(this,"ZstdCompressionStream")}constructor(r){super({async transform(t,n){n.enqueue(await g.compress(t,r))}})}}class L{static{o(this,"ZlibCompressionStream")}readable;writable;constructor(r,t){let n;switch(r){case"br":{const{windowBits:a,level:l,memLevel:d,params:u,...h}=t??{},{BROTLI_PARAM_LGWIN:m,BROTLI_PARAM_QUALITY:s,BROTLI_PARAM_LGBLOCK:p}=c.constants,i={params:{...a&&{[m]:a},...l&&{[s]:l},...d&&{[p]:d},...u},...h};n=c.createBrotliCompress(i);break}case"deflate":{n=c.createDeflate(t);break}case"gzip":{n=c.createGzip(t);break}default:n=c.createDeflateRaw(t)}this.readable=new ReadableStream({async start(a){for await(const l of n.iterator())a.enqueue(l);a.close()}}),this.writable=new WritableStream({write:o(a=>n.write(a),"write"),close:o(()=>n.end(),"close")})}}function G(e){const r=e.find(t=>!w.includes(t));if(r)throw new Error(`Invalid compression encoding: ${r}`)}o(G,"checkCompressEncodings");function v(e){if(!e.res.body||e.req.method==="HEAD")throw Error}o(v,"checkResposeType");function F(e,r,t){if(e.req.header("x-no-compression")||e.res.headers.has("Content-Encoding"))throw Error;const n=Number(e.res.headers.get("Content-Length"));if(n&&n<r||!P(e.res,t)||!z(e.res))throw Error}o(F,"checkResponseCompressible");function M(e,r){if(r!=null){if(!r(e))throw Error}else if(y||N)throw Error}o(M,"checkResponseFilter");function T(e,r){const t=e.req.header("Accept-Encoding");if(t)return r.find(n=>t.includes(n))}o(T,"findAcceptedEncoding");function q(e,r){return T(e,r.filter(t=>t==="gzip"||t==="deflate"))}o(q,"findBackupEncoding");function R({encoding:e,encodings:r=[...w],force:t=!1,threshold:n=D,zstdLevel:a=S,brotliLevel:l=I,gzipLevel:d=k,options:u={},filter:h}={}){return e&&(r=[e]),G(r),o(async function(s,p){await p();try{v(s),F(s,n,t),M(s,h)}catch{return}const i=T(s,r)??(t&&r[0]);if(!i)return;let f;if(i==="zstd")f=new C(a);else if(c){const E=i==="br"?l:d;f=new L(i,{level:E,...u})}else if(CompressionStream){const E=q(s,r);if(!E)return;f=new CompressionStream(E)}f&&(s.res=new Response(s.res.body.pipeThrough(f),s.res),s.res.headers.delete("Content-Length"),s.res.headers.set("Content-Encoding",i))},"compress2")}o(R,"compress");export{L as ZlibCompressionStream,C as ZstdCompressionStream,R as compress,R as default};
